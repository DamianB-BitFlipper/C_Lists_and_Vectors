#include <stdio.h>
#include <stdlib.h> //malloc, ...
#include <string.h> //memcpy, ...

#include "utils.h"  //special types, ie) u32int, u8int

//compile with: gcc -o list_implementation list_implementation.c -O3 -Wall -std=c99

/*********List macros*********/

//!!! ALL MACROS TAKE NON-POINTER ARGS !!!//

/*initializes a list*/
#define LIST_INIT(list) init_list_empty_head(&list);

/*push front*/
#define LIST_PUSH_FRONT(list, var) list.push_front(&list, &var, sizeof(var))

/*pop front*/
#define LIST_POP_FRONT(list) list.pop_front(&list)

/*push back*/
#define LIST_PUSH_BACK(list, var) list.push_back(&list, &var, sizeof(var))

/*pop back*/
#define LIST_POP_BACK(list) list.pop_back(&list)

/*at*/
//the variable out gets the contents of the node's container
#define LIST_AT(list, index, out) list.at(&list, index, &out, 0, sizeof(out))

//same as LIST_AT, with the variable size getting the size of the node's data
#define LIST_AT_WITH_SIZE(list, index, out, size) list.at(&list, index, &out, &size, sizeof(out)) 

/*insert*/
#define LIST_INSERT(list, index, var) list.insert(&list, index, &var, sizeof(var))

/*free all*/
#define LIST_FREE_ALL(list) list.free_all(&list)

/*foreach
 * In struct {...} s:
 *            __typeof__(var) *x is a pointer with the type of var
 *                                  that is initialized with the address of var
 *            list_node_t *node is a pointer to the node in the list
 *                                  that is initialized with the list's head
 *                                  every time the for loop loops, its value is updated
 *                                  with the next node in the list
 * Condition:
 *            while, s.node (the node being iterated) is not NULL, ie) a valid node
 *            and, the extract_container() of the node into the pointer s.x has not failed
 *                     this extract_container function is called every time the condition is executed
 *                     and the value of s.x (*s.x) attains the value of the value container of that node
 *                     As *s.x attains a value, that indirecly makes var attain the same value as
 *                     they were initilized with the same address
 * Iteration:
 *            The next node is assigned the pointer of the current node's next pointer
 *
 * !!! Declaration of var happens outside of LIST_FOREACH loop !!!
 * */
#define LIST_FOREACH(var, list)                                         \
  for(struct { __typeof__(var) *x; list_node_t *node; } s = {&var, list.head}; \
      s.node != NULL && (s.node->extract_container(s.node, s.x, 0, sizeof(var))); \
      s.node = s.node->next)

/*********List macros*********/

//a node in a list
typedef struct list_node_s
{
  //points the the master list struct
  struct list_s *master;

  struct list_node_s *prev, *next;

  u8int *container;
  size_t container_sz;

  //reserved pointer of any extensions
  // can be used by assigning a struct that extends this struct
  void *reserve;
  
  //internal list functions
  struct list_node_s *(*__clone_node__)(struct list_node_s*, struct list_s*, 
                                        struct list_node_s*, struct list_node_s*, void*);

  //function pointers
  bool (*extract_container)(struct list_node_s*, void*, size_t*, size_t);

} list_node_t;

//the entire list itself
typedef struct list_s
{
  list_node_t *head, *tail;
  u32int size; //number of elements

  //reserved pointer of any extensions
  // can be used by assigning a struct that extends this struct
  void *reserve;

  //internal list functions
  list_node_t *(*__get_node_at__)(struct list_s*, u32int);

  //function pointers
  bool (*push_front)(struct list_s*, void*, size_t);
  bool (*pop_front)(struct list_s*);
  bool (*push_back)(struct list_s*, void*, size_t);
  bool (*pop_back)(struct list_s*);
  bool (*at)(struct list_s*, u32int, void*, size_t*, size_t);
  bool (*insert)(struct list_s*, u32int, void*, size_t);
  bool (*free_all)(struct list_s*);
  bool (*clone)(struct list_s*, struct list_s*);
} list_t;


list_node_t *__list_node_clone_node__(list_node_t *self, list_t *master, 
                                      list_node_t *prev, list_node_t *next, void *reserve)
{
  list_node_t *copy;
  copy = (list_node_t*)malloc(sizeof(list_node_t));

  //copy the data
  copy->master = master;
  copy->prev = prev;
  copy->next = next;

  //allocate and copy the containers seperatly
  copy->container = (u8int*)malloc(self->container_sz);
  memcpy(copy->container, self->container, self->container_sz);

  copy->container_sz = self->container_sz;
  copy->reserve = reserve;

  return copy;
}

bool list_node_extract_container(list_node_t *node, void *outData, size_t *outSize, size_t actualContainerSize)
{
  //exit because node was NULL
  if(!node)
    return false; //error

  if(outData)
  {
    if(actualContainerSize < node->container_sz)
      return false; //error
    memcpy(outData, node->container, node->container_sz);
  }
    
  //if outSize is NULL, no need to set it
  if(outSize)
    *outSize = node->container_sz;

  return true;
}

void init_list_node(list_t *master, list_node_t *node, list_node_t *prev, 
                    list_node_t *next, void *elem, size_t size)
{
  //initialize
  node->master = master;
  node->prev = prev;
  node->next = next;

  //memcpy the container data
  node->container = (u8int*)malloc(size);
  memcpy(node->container, elem, size);

  node->container_sz = size;

  //the reserve will be NULL in this case
  node->reserve = NULL;

  //internal list functions
  node->__clone_node__ = __list_node_clone_node__;

  //assign corresponding functions
  node->extract_container = list_node_extract_container;
  
  return;
}

/***********************************************
 *                                             *
 * Internal List Functions                     *
 *                                             *
 ***********************************************/

list_node_t *__list_get_node_at__(list_t *self, u32int index)
{
  list_node_t *node;
  u32int i;

  //for efficiency, if index is near the begining of the list, start from the front
  // else start from the back and work way to front
  if(index / (float)self->size <= 0.5) //start from front
  {
    node = self->head;

    for(i = 0; node && i < index; i++, node = node->next);

  }else{ //start from the end
    node = self->tail;

    for(i = self->size - 1; node && i > index; i++, node = node->prev);
  }

  return node;
}

/***********************************************
 *                                             *
 * Internal List Functions                     *
 *                                             *
 ***********************************************/


/***********************************************
 *                                             *
 * External List Functions                     *
 *                                             *
 ***********************************************/

//creates a list node with contents *elem and pushes it to the front of the list
bool list_push_front(list_t *self, void *elem, size_t size)
{
  //Sanity checks
  if(!self || !elem)
    return false; //error

  //malloc for a node
  list_node_t *node = (list_node_t*)malloc(sizeof(list_node_t));

  //this list is empty, make the head
  if(!self->head || !self->tail)
  {
    init_list_node(self, node, NULL, NULL, elem, size);

    //the head and tail will be equal
    self->head = self->tail = node;
  }else{
    /*initialize a node with
     * the prev node being NULL
     * the next node being the current head of self*/
    init_list_node(self, node, NULL, self->head, elem, size);    

    //on the old head of the list, make the prev this node
    self->head->prev = node;

    //make the head of the list this node
    self->head = node;
  }

  //increment self's size
  self->size++;

  //sucess!
  return true;
}

//creates a list node with contents *elem and pushes it to the back of the list
bool list_push_back(list_t *self, void *elem, size_t size)
{
  //Sanity checks
  if(!self || !elem)
    return false; //error

  //malloc for a node
  list_node_t *node = (list_node_t*)malloc(sizeof(list_node_t));

  //this list is empty, make the head
  if(!self->head || !self->tail)
  {
    init_list_node(self, node, NULL, NULL, elem, size);

    //the head and tail will be equal
    self->head = self->tail = node;
  }else{
    /*initialize a node with
     * the prev node being the tail of self
     * the next node being NULL*/
    init_list_node(self, node, self->tail, NULL, elem, size);    

    //on the old tail of the list, make the next this node
    self->tail->next = node;

    //make the tail of the list this node
    self->tail = node;
  }

  //increment self's size
  self->size++;

  //sucess!
  return true;
}

//removes the first element in the list self
bool list_pop_front(list_t *self)
{
  //sanity checks
  if(!self || !self->tail)
    return false;

  list_node_t *node = self->head;
  
  //set the head now to the node's next
  self->head = node->next;
  //the head's prev has to be cleared
  self->head->prev = NULL;

  //decrement the size
  self->size--;

  //if the size is 0, make the tail of the list NULL also
  if(!self->size)
    self->tail = NULL;

  //free the container and the node itself
  free(node->container);
  free(node);

  return true;
}

//removes the last element in the list self
bool list_pop_back(list_t *self)
{
  //sanity checks
  if(!self || !self->tail)
    return false;

  list_node_t *node = self->tail;
  
  //set the tail now to the node's prev
  self->tail = node->prev;
  //the tail's next has to be cleared
  self->tail->next = NULL;

  //decrement the size
  self->size--;

  //if the size is 0, make the head of the list NULL also
  if(!self->size)
    self->head = NULL;

  //free the container and the node itself
  free(node->container);
  free(node);

  return true;
}

//at the list self, assigns outData the contents of the node at index index
//
//actualContainerSize is the size of the container behind the void*
// this function will detect if it is too small and error out
bool list_at(list_t *self, u32int index, void *outData, size_t *outSize, size_t actualContainerSize)
{
  //santiy checks
  if(!self || index >= self->size)
    return false; //error

  list_node_t *node = self->__get_node_at__(self, index);

  //sanity check
  if(!node)
     return false; //error

  //node is now the node at the desired index, extract its information
  return node->extract_container(node, outData, outSize, actualContainerSize);
}

//inserts element 'void *elem' with size 'size_t size' at index 'u32int index' in self
bool list_insert(struct list_s *self, u32int index, void *elem, size_t size)
{
  //sanity checks
  if(!elem || ! size || !self || index > self->size)
    return false; //error

  //handle the end cases differently
  // use push front/back if the index is the beginning/end
  if(!index) //index is the first element
    return self->push_front(self, elem, size);
  else if(index == self->size) //index is past the last element
    return self->push_back(self, elem, size);
  
  //The index is somewhere inside of the list
    
  //index - 1 will get the node in the list that will preceed this inserted node
  // prev_node will be guaranteed to have a next node and
  // next will be guaranteed to have a prev node
  // as the end cases were handled in the above if statements
  list_node_t *prev_node = self->__get_node_at__(self, index - 1);

  //sanity checks
  if(!prev_node || !prev_node->next || !prev_node->next->prev)
    return false; //error

  list_node_t *next_node = prev_node->next;

  //create this node
  list_node_t *node = (list_node_t*)malloc(sizeof(list_node_t)); //malloc for a node
  init_list_node(self, node, prev_node, next_node, elem, size);

  //break the link between prev and next and insert node between them
  prev_node->next = next_node->prev = node;

  //increment the self's size
  self->size++;

  //sucess!
  return true;

}

bool list_free_all(list_t *self)
{
  //sanity check
  if(!self)
    return false; //error

  list_node_t *node = self->head;

  while(node)
  {
    list_node_t *next_node = node->next;

    //free the container and node
    free(node->container);
    free(node);

    //assign the next node to node
    node = next_node;
  }

  //set the head and tail of the list to NULL
  self->head = self->tail = NULL;

  //sucess!
  return true;
}

bool list_clone(list_t *self, list_t *ret)
{
  list_node_t *node = self->head;
  list_node_t *prev_node = NULL;

  for(; node; node = node->next)
  {
    list_node_t *insert = node->__clone_node__(node, ret, prev_node, NULL, node->reserve);

    printf("insert %p %p\n", insert, prev_node);

    //set the previous node's next as this insert if prev_node exits
    if(prev_node)
      prev_node->next = insert;
    else //insert is the first element, set it as the list's head
      ret->head = insert;

    //before the loop loops, prev_node is set and then node will be set to next,
    // that makes prev node be the previous node in the next loop
    prev_node = insert;
  }
  
  //prev_node is now the last element in the list, set it as the list's tail
  ret->tail = prev_node;

  //copy the size over
  ret->size = self->size;

  return true;
}

void init_list_empty_head(list_t *list)
{
  //all values to be set to 0
  list->head = list->tail = 0;
  list->size = 0;

  //the reserve will be NULL in this case
  list->reserve = NULL;

  //assign internal list functions not meant to be called by the user
  list->__get_node_at__ = __list_get_node_at__;

  //assign corresponding functions
  list->push_front = list_push_front;
  list->pop_front  = list_pop_front;
  list->push_back  = list_push_back;
  list->pop_back   = list_pop_back;
  list->at         = list_at;
  list->insert     = list_insert;
  list->free_all   = list_free_all;

  return;
}

/***********************************************
 *                                             *
 * External List Functions                     *
 *                                             *
 ***********************************************/

s32int main()
{
  list_t list;
  LIST_INIT(list);

  //Test variables
  u32int test = 100, mid = 200, end = 300;

  struct sTest_s
  {
    u32int test;
    uint64 wow;
    u32int to;
  } sTest;

  sTest.test = sTest.wow = sTest.to = 10;
  //Test variables

  LIST_PUSH_BACK(list, test);
  LIST_PUSH_BACK(list, mid);
  LIST_PUSH_BACK(list, end);

  LIST_PUSH_FRONT(list, end);
  LIST_PUSH_FRONT(list, end);
  LIST_PUSH_FRONT(list, end);
  LIST_POP_BACK(list);

  LIST_INSERT(list, 1, mid);

  u32int foreachTmp;
  LIST_FOREACH(foreachTmp, list)
  {
    printf("Test %d\n", foreachTmp);
  }

  list_t copy_list;
  LIST_INIT(copy_list);
  list_clone(&list, &copy_list);

  printf("-----------------\n");

  LIST_FREE_ALL(list);
  LIST_FOREACH(foreachTmp, copy_list)
  {
    printf("Test %d\n", foreachTmp);
  }

  /*u32int nice, in = 2;
  LIST_AT(list, in, nice);
  printf("At %d is %d size %d\n", in, nice, list.size);

  printf("HEAD %d TAIL %p:%d\n", 
         *(u32int*)(list.head->next->next->prev->container), 
         (list.tail->container), *(u32int*)(list.tail->container));*/

  return 0;
}
